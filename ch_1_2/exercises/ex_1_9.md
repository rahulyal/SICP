### Exercise 1.9.

```
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
# iterative approach
(define (+ a b)
	(if (= a 0)
		b
		(+ (dec a) (inc b)))
)
# recursive approach
(define (+ a b)
	(if (= a 0)
		b
		(inc (+ (dec a) b)))
)
```

In iterative approach, at any point if the system breaks, given the last call, it is enough information to still go through and calculate the answer, as there is no extra stack space we are using here, like remembering how many increments are yet to be done in the outer layer here.
Using the substitution model, the process generated by each procedure is illustrated as follows:
Method 1: iterative approach
```
> (+ 4 5)
> (+ 3 6)
> (+ 2 7)
> (+ 1 8)
> (+ 0 9)
> 9
```
Method 2: recursive approach
```
> (+ 4 5)
> (inc (+ 3 5))
> (inc (inc (+ 2 5)))
> (inc (inc (inc (+ 1 5))))
> (inc (inc (inc (inc (+ 0 5)))))
> (inc (inc (inc (inc 5))))
> (inc (inc (inc 6)))
> (inc (inc 7))
> (inc 8)
> 9
```
Although both the approaches give you the same answer, and also would feel like recursive operations, while the procedures themselves are both recursive, the processes are not both recursive, one of them is iterative as at every state we know exactly via the state variables to the function call what we need to have the final answer, whereas in a recursive process this is not possible, as we need to also have external stack information on how many increments we are yet to do on the funtional parameters to get our final answer.
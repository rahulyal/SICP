# Notes for
**1.2 Procedures and the processes they generate**
To become programming experts, we must learn to visualize the processes generated by various types of procedures.
procedure is like an engineering design that we come up with, or the spells we write, whether this can actually happen in practice, or can be executed on the system is defined later on, when it is translated into processes where the machine runs them, so understanding and visualizing these processes will help us write better procedures. (better explanation in video lecture)
---
**1.2.1 Linear recursion and iteration**

In iterative approach, at any point if the system breaks, given the last call, it is enough information to still go through and calculate the answer, as there is no extra stack space we are using here, like remembering how many multiplications we are yet to do given a factorial.
```
(define (fact-recur x)
	(if (= x 0)
		1
		(* x (fact-recur (- x 1)))
	)
)
```
Using substitution model,
if we are calculating (fact-recur 5)
```
> (fact-recur 5)
> (* 5 (fact-recur 4))
> (* 5 (* 4 (fact-recur 3)))
> (* 5 (* 4 (* 3 (fact-recur 2))))
> (* 5 (* 4 (* 3 (* 2 (fact-recur 1)))))
> (* 5 (* 4 (* 3 (* 2 (* 1 (fact-recur 0))))))
> (* 5 (* 4 (* 3 (* 2 (* 1 1)))))
> (* 5 (* 4 (* 3 (* 2 1))))
> (* 5 (* 4 (* 3 2)))
> (* 5 (* 4 6))
> (* 5 24)
> 120
```

As explained before, we would need to hold the stack space in a recursive call, where as in the following iterative procedure, we would not need to hold any stack space, as at any given point, all the information we need is just the procedures variables, no extra stack space required to hold on what multiplications are yet needed to be done.

```
(define (fact-iter x)
	(define (helper ans i x)
		(if  (= i x)
			(* i ans)
			(helper (* i ans) (+ i 1) x))
	)
	(helper 1 1 x)
)
```
Using substitution model, 
if we are calculating (fact-iter 5)
```
> (fact-iter 5)
> (helper 1 1 5)
> (helper 1 2 5)
> (helper 2 3 5)
> (helper 6 4 5)
> (helper 24 5 5)
> (* 24 5)
> 120
```
the space here does not grow and shrink as in the recursive approach, so in the iterative approach at any given point the program variables themselves provide the complete description of the state of the process at any point.
Exercise.1.9:(look at explantion)
Exercise.1.10:
---
**1.2.2 Tree Recursion**

